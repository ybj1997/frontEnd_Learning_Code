<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        1.原始创建Object模式
          *方法：先创建一个空Object对象，再动态添加属性/方法
          *缺点：1.语句重复
                2.起始属性值是可以变化的 
        */
       var obj = new Object();
       obj.name = 'jack';
       obj.age = 18;
       obj.setName = function(name){
           this.name = name;
       }
       //输出
       obj.setName('abc');
       console.log(obj.name,obj.age);

       /*
       2.对象字面量模式
         *方法：使用{}创建对象，同时指定属性和方法
         *缺点：1.起始时对象内部属性是确定的
               2.如果创建多个对象，有重复代码
       */

       var obj1 = {
           name:'tom',
           age:19,
           setName1:function(name){
               this.name = name;
           }
       }
       //测试
       obj1.setName1('abc');
       console.log(obj1.name,obj1.age);

       /*
       3.工厂模式
         *方法：通过工厂动态创建对象并返回
         *缺点：1.对象没有具体类型，都是Object类型
       */
      function creatobj(name,age){
          var obj3 = {
              name:name,
              age:age,
              setName3 :function(){
                  this.name = name;
              }
          }
          return obj3;
      }
      //测试
      var person1 = creatobj('ybj',24);
      var person2 = creatobj('gzy',22);
      console.log(person1,person2); 
      console.log(typeof person1);
      console.log(typeof person2);

      /*
      4.构造函数模式
         *方法：自定义一个构造函数，而后实例化赋值
         *缺点：每个对象中的基本数据不同，但有相同代码
      */
     function Person(name,age) {
         this.name = name;
         this.age = age;
         this.setName3 = function (name) {
             this.name = name;
         }
     }
     var per = new Person('simon',30);
     console.log(per);//一个自定义的对象
     console.log(typeof per);//typeof用于判断基础数据类型和函数，所以在此处不适用
     console.log(per instanceof Person);//判断引用数据类型，Person是一个函数

     /*
     5.构造函数的原型中添加方法
     */
     function Person(name,age) {
         this.name = name;
         this.age = age;
     }
     Person.prototype.fn = function (name) {
         this.name = name;
     }
     var per = new Person('simon',30);
     var per1 = new Person('jack',22);
     console.log(per,per1);
    </script>
</body>
</html>