<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button>测试1</button>
    <button>测试2</button>
    <button>测试3</button>
</body>
<script>
    let btns = document.querySelectorAll('button');
    //for(var i = 0;i < btns.length;i++){
    //    let index = i;
    //    btns[i].addEventListener('click',function(){
    //        alert('您正在点击第'+(index+1)+'个按钮')
    //    })
    //}

    //闭包
    for(var i = 0;i < btns.length;i++){
        (function(i){
            btns[i].addEventListener('click',function(){
            alert('您正在点击第'+(i+1)+'个按钮')
        })
        })(i)
    }
    /*
    1.如何产生闭包？
      *当一个嵌套的内部（子）函数引用了嵌套外部（父）函数的变量（函数）时，就产生了闭包
    2.闭包到底是什么？
      *理解一：闭包是嵌套的内部（子）函数
      *理解二：包含被引用变量的对象
               闭包存在于嵌套的内部函数中
    3.产生条件
      *函数嵌套
      *嵌套中的内部函数引用了外部函数的变量（或者函数）
    */
   function fn1(){
       var a =2;
       function fn2(){//执行函数定定义时，就会产生闭包，不一定非要执行这个函数
           console.log(a);
       }
   }
   fn1()

   /*
   1.缺点
     *函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
     *容易造成内存泄漏
   2.解决
     *(能不用闭包就不用)
     *用完及时释放
   */
  function fn1 (){
      //外部调用函数，内部执行函数定义，变量和函数提升，内部函数调用局部变量，产生闭包
      var arr = new Array[10000];
      function fn2(){
          console.log(arr);
      }
  }
  var f = fn1();//调用fn1产生闭包，用变量f来保存闭包地址
  f();//调用闭包
  f = null;//释放内存，让内部函数成为垃圾对象--->回收闭包
</script>

</html>